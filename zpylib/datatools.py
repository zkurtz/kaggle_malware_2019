from feather import read_dataframe as read_feather
import numpy as np
import pandas as pd
from time import time

def read_response(f):
    col = 'HasDetections'
    return read_feather(f, columns=[col])[col].values

def multi_read_response(files):
    return np.concatenate([read_response(f) for f in files])

class FeaturesByType(object):
    categorical = [
        'ProductName', 'EngineVersion', 'AppVersion', 'AvSigVersion', 'IsBeta', 'IsSxsPassiveMode',
        'DefaultBrowsersIdentifier', 'AVProductStatesIdentifier', 'HasTpm', 'CountryIdentifier',
        'CityIdentifier', 'OrganizationIdentifier', 'GeoNameIdentifier', 'LocaleEnglishNameIdentifier',
        'Platform', 'Processor', 'OsVer', 'OsPlatformSubRelease', 'OsBuildLab', 'SkuEdition',
        'IsProtected', 'AutoSampleOptIn', 'PuaMode', 'SMode', 'IeVerIdentifier', 'SmartScreen',
        'Firewall', 'Census_MDC2FormFactor', 'Census_DeviceFamily', 'Census_OEMNameIdentifier',
        'Census_OEMModelIdentifier', 'Census_ProcessorManufacturerIdentifier',
        'Census_ProcessorModelIdentifier', 'Census_ProcessorClass', 'Census_PrimaryDiskTypeName',
        'Census_HasOpticalDiskDrive', 'Census_ChassisTypeName', 'Census_PowerPlatformRoleName',
        'Census_InternalBatteryType', 'Census_OSVersion', 'Census_OSArchitecture', 'Census_OSBranch',
        'Census_OSEdition', 'Census_OSSkuName', 'Census_OSInstallTypeName',
        'Census_OSInstallLanguageIdentifier', 'Census_OSUILocaleIdentifier',
        'Census_OSWUAutoUpdateOptionsName', 'Census_IsPortableOperatingSystem',
        'Census_GenuineStateName', 'Census_ActivationChannel', 'Census_IsFlightingInternal',
        'Census_IsFlightsDisabled', 'Census_FlightRing', 'Census_ThresholdOptIn',
        'Census_FirmwareManufacturerIdentifier', 'Census_FirmwareVersionIdentifier',
        'Census_IsSecureBootEnabled', 'Census_IsWIMBootEnabled', 'Census_IsVirtualDevice',
        'Census_IsTouchEnabled', 'Census_IsPenCapable', 'Census_IsAlwaysOnAlwaysConnectedCapable',
        'Wdft_IsGamer', 'Wdft_RegionIdentifier'
    ]
    continuous = [
        'RtpStateBitfield', 'AVProductsInstalled', 'AVProductsEnabled', 'OsBuild', 'OsSuite',
        'UacLuaenable', 'Census_ProcessorCoreCount', 'Census_PrimaryDiskTotalCapacity',
        'Census_SystemVolumeTotalCapacity', 'Census_TotalPhysicalRAM',
        'Census_InternalPrimaryDiagonalDisplaySizeInInches',
        'Census_InternalPrimaryDisplayResolutionHorizontal',
        'Census_InternalPrimaryDisplayResolutionVertical', 'Census_InternalBatteryNumberOfCharges',
        'Census_OSBuildNumber', 'Census_OSBuildRevision',
        'raw_data_index'
    ]
    version = ['EngineVersion', 'AppVersion', 'AvSigVersion', 'Census_OSVersion', 'OsVer']
    predictors = categorical + continuous
    meta = ['MachineIdentifier', 'is_train']
    response = 'HasDetections'
    # Exploratory work suggested that many categorical features could also have value if used as continuous features:
    categorical_as_continuous=[
        'Census_OSWUAutoUpdateOptionsName', 'Census_ChassisTypeName', 'Census_OSVersion',
        'Census_ProcessorModelIdentifier', 'Census_OSEdition', 'OsBuildLab', 'Wdft_RegionIdentifier', 'AppVersion',
        'EngineVersion', 'Census_OEMNameIdentifier', 'SkuEdition', 'CountryIdentifier', 'AvSigVersion',
        'Census_FirmwareManufacturerIdentifier', 'OsPlatformSubRelease', 'SmartScreen', 'AVProductStatesIdentifier',
        'Census_OSInstallTypeName', 'IeVerIdentifier', 'CityIdentifier', 'Census_FirmwareVersionIdentifier',
        'Census_FlightRing', 'OrganizationIdentifier', 'Census_ActivationChannel', 'GeoNameIdentifier',
        'DefaultBrowsersIdentifier', 'Census_OSBranch', 'Census_OSInstallLanguageIdentifier',
        'LocaleEnglishNameIdentifier', 'Census_GenuineStateName', 'Census_OEMModelIdentifier',
        'Census_OSUILocaleIdentifier'
    ]
    def __init__(self, expand_categorical_as_continuous=False):
        if expand_categorical_as_continuous:
            fnames = ['continuous_' + s for s in self.categorical_as_continuous]
            self.predictors += fnames
            self.continuous += fnames

        # Recategorize some categoricals as continuous
        self.continuous = self.continuous + self.version
        self.categorical = [s for s in self.categorical if s not in self.version]

    def select(self, features):
        self.predictors = [s for s in self.predictors if s in features]
        self.categorical = [s for s in self.categorical if s in features]
        self.continuous = [s for s in self.continuous if s in features]

class Data(object):
    def __init__(self, df, expand_categorical_as_continuous=False,
                 select=None, target='HasDetections', extra_predictors = None):
        self.coltypes = FeaturesByType(expand_categorical_as_continuous)
        if expand_categorical_as_continuous:
            fnames = self.coltypes.categorical_as_continuous
            cdf = df[fnames].copy()
            cdf.columns=['continuous_' + s for s in fnames]
            df = pd.concat([df, cdf], axis=1)
        if select is not None:
            assert isinstance(select, list)
            self.coltypes.select(select)
        # predcols = [p for p in self.coltypes.predictors if p in df.columns]
        if target in df.columns:
            self.y = df[target].values
        if extra_predictors is None:
            extra_predictors = []
        predictors_list = self.coltypes.predictors + extra_predictors
        preds = [p for p in predictors_list if p in df.columns]
        for v in list(set(df.columns) - set(preds + [target])):
            print("ignoring " + v)
        self.X = df[preds].copy()
        metacols = [p for p in self.coltypes.meta if p in df.columns]
        self.metadata = df[metacols].copy()

    def describe_predictors(self):
        pcols = self.coltypes.predictors
        X = self.X
        types = pd.DataFrame({
            'cols': X.columns,
            'typ': [X[v].dtype for v in pcols],
            'nuniq': [X[v].nunique(dropna=False) for v in pcols]
        })
        return types

def data_from_feather(file, threshold=5):
    print("reading feather " + file)
    t0 = time()
    df=read_feather(file)
    tdiff = round(time() - t0)
    if tdiff > threshold:
        print(" ... that took " + str(tdiff) + " seconds")
    return Data(df)

def identify_version_features():
    ''' Return a list of feature names for version features of the form <x.x.x.x> '''
    ftypes = FeaturesByType()
    fnames = [p for p in ftypes.predictors if 'Version' in p]
    fnames.remove('Census_FirmwareVersionIdentifier')
    return fnames + ['OsVer']